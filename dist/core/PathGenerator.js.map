{"version":3,"file":"PathGenerator.js","names":["points: Array<{ x: number; y: number }>"],"sources":["../../src/core/PathGenerator.ts"],"sourcesContent":["/**\n * BlobPathGenerator - SVG path generation for blob shapes\n *\n * Pure TypeScript implementation for SSR-safe path generation.\n */\n\nimport type { RenderBlob } from './schema.js';\n\n/**\n * Generate SVG path string\n */\nexport async function generateSmoothBlobPath(blob: RenderBlob): Promise<string> {\n\treturn generateFallbackPath(blob);\n}\n\n/**\n * Synchronous path generation for render loops\n */\nexport function generateSmoothBlobPathSync(blob: RenderBlob): string {\n\treturn generateFallbackPath(blob);\n}\n\n/**\n * Fallback path generation using pure TypeScript\n */\nfunction generateFallbackPath(blob: RenderBlob): string {\n\tconst cx = blob.currentX;\n\tconst cy = blob.currentY;\n\tconst r = blob.size;\n\tconst phase = blob.phase || 0;\n\n\t// Generate 8 points around circle with slight deformation\n\tconst points: Array<{ x: number; y: number }> = [];\n\tfor (let i = 0; i < 8; i++) {\n\t\tconst angle = (i / 8) * Math.PI * 2;\n\t\t// Simple organic variation\n\t\tconst radiusMod = 1.0 + 0.1 * Math.sin(angle * 2 + phase);\n\t\tconst x = cx + Math.cos(angle) * r * radiusMod;\n\t\tconst y = cy + Math.sin(angle) * r * radiusMod;\n\t\tpoints.push({ x, y });\n\t}\n\n\t// Build path with cubic bezier curves\n\tlet path = `M ${points[0].x.toFixed(2)},${points[0].y.toFixed(2)}`;\n\tconst smoothing = 0.15;\n\n\tfor (let i = 0; i < 8; i++) {\n\t\tconst curr = points[i];\n\t\tconst next = points[(i + 1) % 8];\n\t\tconst nextNext = points[(i + 2) % 8];\n\n\t\tconst cp1x = curr.x + (next.x - curr.x) * smoothing;\n\t\tconst cp1y = curr.y + (next.y - curr.y) * smoothing;\n\t\tconst cp2x = next.x - (nextNext.x - curr.x) * (smoothing * 0.3);\n\t\tconst cp2y = next.y - (nextNext.y - curr.y) * (smoothing * 0.3);\n\n\t\tpath += ` C ${cp1x.toFixed(2)},${cp1y.toFixed(2)} ${cp2x.toFixed(2)},${cp2y.toFixed(2)} ${next.x.toFixed(2)},${next.y.toFixed(2)}`;\n\t}\n\n\tpath += ' Z';\n\treturn path;\n}\n\n/**\n * Batch path generation for multiple blobs\n */\nexport async function generateBlobPathsBatch(blobs: RenderBlob[]): Promise<string[]> {\n\treturn blobs.map((blob) => generateFallbackPath(blob));\n}\n\n/**\n * Synchronous batch path generation\n */\nexport function generateBlobPathsBatchSync(blobs: RenderBlob[]): string[] {\n\treturn blobs.map((blob) => generateFallbackPath(blob));\n}\n\n/**\n * Pre-initialize path generator (no-op, for API compatibility)\n */\nexport async function preInitPathGenerator(): Promise<boolean> {\n\treturn true;\n}\n\n/**\n * Check if path generator is ready (always true)\n */\nexport function isPathGeneratorReady(): boolean {\n\treturn true;\n}\n"],"mappings":"AAWA,eAAsB,EAAuB,GAAmC;AAC/E,SAAO,EAAqB,CAAA;;AAM7B,SAAgB,EAA2B,GAA0B;AACpE,SAAO,EAAqB,CAAA;;AAM7B,SAAS,EAAqB,GAA0B;AACvD,QAAM,IAAK,EAAK,UACV,IAAK,EAAK,UACV,IAAI,EAAK,MACT,IAAQ,EAAK,SAAS,GAGtBA,IAA0C,CAAA;AAChD,WAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC3B,UAAM,IAAS,IAAI,IAAK,KAAK,KAAK,GAE5B,IAAY,IAAM,MAAM,KAAK,IAAI,IAAQ,IAAI,CAAA,GAC7C,IAAI,IAAK,KAAK,IAAI,CAAA,IAAS,IAAI,GAC/B,IAAI,IAAK,KAAK,IAAI,CAAA,IAAS,IAAI;AACrC,IAAA,EAAO,KAAK;AAAA,MAAE,GAAA;AAAA,MAAG,GAAA;AAAA,KAAG;AAAA;AAIrB,MAAI,IAAO,KAAK,EAAO,CAAA,EAAG,EAAE,QAAQ,CAAA,CAAE,IAAI,EAAO,CAAA,EAAG,EAAE,QAAQ,CAAA,CAAE;AAChE,QAAM,IAAY;AAElB,WAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC3B,UAAM,IAAO,EAAO,CAAA,GACd,IAAO,GAAQ,IAAI,KAAK,CAAA,GACxB,IAAW,GAAQ,IAAI,KAAK,CAAA,GAE5B,IAAO,EAAK,KAAK,EAAK,IAAI,EAAK,KAAK,GACpC,IAAO,EAAK,KAAK,EAAK,IAAI,EAAK,KAAK,GACpC,IAAO,EAAK,KAAK,EAAS,IAAI,EAAK,MAAM,IAAY,MACrD,IAAO,EAAK,KAAK,EAAS,IAAI,EAAK,MAAM,IAAY;AAE3D,IAAA,KAAQ,MAAM,EAAK,QAAQ,CAAA,CAAE,IAAI,EAAK,QAAQ,CAAA,CAAE,IAAI,EAAK,QAAQ,CAAA,CAAE,IAAI,EAAK,QAAQ,CAAA,CAAE,IAAI,EAAK,EAAE,QAAQ,CAAA,CAAE,IAAI,EAAK,EAAE,QAAQ,CAAA,CAAE;AAAA;AAGjI,SAAA,KAAQ,MACD;;AAoBR,eAAsB,IAAyC;AAC9D,SAAO"}