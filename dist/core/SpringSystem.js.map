{"version":3,"file":"SpringSystem.js","names":["DEFAULT_SPRING_CONFIG: SpringConfig","velocities: ControlPointVelocity[]"],"sources":["../../src/core/SpringSystem.ts"],"sourcesContent":["/**\n * Spring-Damper System for Gel Physics\n *\n * Implements realistic gel deformation using mass-spring-damper model.\n * Each control point is a mass connected by springs to:\n * 1. Its rest position (baseRadius)\n * 2. Neighboring control points (coupling)\n * 3. Global pressure (outward force)\n *\n * F_total = F_spring + F_tension + F_pressure + F_coupling + F_damping\n */\n\nimport type { ControlPoint, ControlPointVelocity } from './types.js';\n\n/**\n * Extended control point with spring physics properties\n */\nexport interface GelControlPoint extends ControlPoint {\n\t// Spring properties\n\tspringConstant: number; // k - stiffness to base radius\n\tdampingCoeff: number; // c - velocity damping\n\tcouplingStrength: number; // Spring constant to neighbors\n\tmass: number; // Mass (affects acceleration)\n\n\t// State\n\tradialVelocity: number;\n\tangularVelocity: number;\n}\n\n/**\n * Spring system configuration\n */\nexport interface SpringConfig {\n\t/** Spring constant for return to base radius (0.01 - 0.5) */\n\tspringConstant: number;\n\t/** Damping coefficient for velocity decay (0.01 - 0.3) */\n\tdampingCoeff: number;\n\t/** Coupling strength between neighbors (0.01 - 0.2) */\n\tcouplingStrength: number;\n\t/** Surface tension toward circular shape (0.0 - 0.1) */\n\tsurfaceTension: number;\n\t/** Internal pressure (0.5 - 2.0, 1.0 = neutral) */\n\tpressure: number;\n\t/** Maximum radius deviation from base (0.1 - 0.5) */\n\tmaxDeformation: number;\n\t/** Maximum velocity (prevents explosion) */\n\tmaxVelocity: number;\n}\n\nexport const DEFAULT_SPRING_CONFIG: SpringConfig = {\n\tspringConstant: 0.08,\n\tdampingCoeff: 0.12,\n\tcouplingStrength: 0.05,\n\tsurfaceTension: 0.03,\n\tpressure: 1.0,\n\tmaxDeformation: 0.3,\n\tmaxVelocity: 2.0,\n};\n\n/**\n * Spring System for gel-like control point deformation\n */\nexport class SpringSystem {\n\tprivate config: SpringConfig;\n\n\tconstructor(config: Partial<SpringConfig> = {}) {\n\t\tthis.config = { ...DEFAULT_SPRING_CONFIG, ...config };\n\t}\n\n\t/**\n\t * Update a single control point using spring physics\n\t *\n\t * @param point - Control point to update\n\t * @param velocity - Velocity state for the control point\n\t * @param leftNeighbor - Left neighboring control point\n\t * @param rightNeighbor - Right neighboring control point\n\t * @param externalForce - External radial force (from collisions, gravity, etc.)\n\t * @param dt - Delta time in seconds\n\t */\n\tupdateControlPoint(\n\t\tpoint: ControlPoint,\n\t\tvelocity: ControlPointVelocity,\n\t\tleftNeighbor: ControlPoint,\n\t\trightNeighbor: ControlPoint,\n\t\texternalForce: number,\n\t\tdt: number\n\t): void {\n\t\t// 1. Spring force to base radius (Hooke's law: F = -kx)\n\t\tconst displacement = point.radius - point.baseRadius;\n\t\tconst F_spring = -this.config.springConstant * displacement;\n\n\t\t// 2. Surface tension (pull toward average of neighbors)\n\t\tconst avgNeighborRadius = (leftNeighbor.radius + rightNeighbor.radius) / 2;\n\t\tconst tensionDisplacement = point.radius - avgNeighborRadius;\n\t\tconst F_tension = -this.config.surfaceTension * tensionDisplacement;\n\n\t\t// 3. Pressure force (uniform outward/inward force)\n\t\tconst pressureDeviation = this.config.pressure - 1.0;\n\t\tconst F_pressure = pressureDeviation * point.baseRadius * 0.01;\n\n\t\t// 4. Neighbor coupling (spring forces to neighbors)\n\t\tconst leftDisplacement = leftNeighbor.radius - point.radius;\n\t\tconst rightDisplacement = rightNeighbor.radius - point.radius;\n\t\tconst F_coupling = this.config.couplingStrength * (leftDisplacement + rightDisplacement) * 0.5;\n\n\t\t// 5. Damping (viscosity: F = -cv)\n\t\tconst F_damping = -this.config.dampingCoeff * velocity.radialVelocity;\n\n\t\t// 6. External forces\n\t\tconst F_external = externalForce;\n\n\t\t// Total force\n\t\tconst F_total = F_spring + F_tension + F_pressure + F_coupling + F_damping + F_external;\n\n\t\t// Update velocity (F = ma, assume m = 1)\n\t\tvelocity.radialVelocity += F_total * dt;\n\n\t\t// Clamp velocity to prevent explosion\n\t\tvelocity.radialVelocity = Math.max(\n\t\t\t-this.config.maxVelocity,\n\t\t\tMath.min(this.config.maxVelocity, velocity.radialVelocity)\n\t\t);\n\n\t\t// Update position\n\t\tpoint.radius += velocity.radialVelocity * dt;\n\n\t\t// Clamp radius to prevent extreme deformation\n\t\tconst minRadius = point.baseRadius * (1 - this.config.maxDeformation);\n\t\tconst maxRadius = point.baseRadius * (1 + this.config.maxDeformation);\n\t\tpoint.radius = Math.max(minRadius, Math.min(maxRadius, point.radius));\n\n\t\t// If clamped, zero out velocity in that direction\n\t\tif (point.radius === minRadius || point.radius === maxRadius) {\n\t\t\tvelocity.radialVelocity *= 0.3; // Bounce damping\n\t\t}\n\t}\n\n\t/**\n\t * Update all control points for a blob\n\t *\n\t * @param points - Array of control points\n\t * @param velocities - Array of velocity states\n\t * @param externalForces - Per-point external forces (or single force for all)\n\t * @param dt - Delta time in seconds\n\t */\n\tupdateAllControlPoints(\n\t\tpoints: ControlPoint[],\n\t\tvelocities: ControlPointVelocity[],\n\t\texternalForces: number | number[],\n\t\tdt: number\n\t): void {\n\t\tconst n = points.length;\n\t\tif (n < 3) return;\n\n\t\t// Pre-compute neighbor indices (circular)\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tconst leftIdx = (i - 1 + n) % n;\n\t\t\tconst rightIdx = (i + 1) % n;\n\n\t\t\tconst externalForce = Array.isArray(externalForces)\n\t\t\t\t? externalForces[i] || 0\n\t\t\t\t: externalForces;\n\n\t\t\tthis.updateControlPoint(\n\t\t\t\tpoints[i],\n\t\t\t\tvelocities[i],\n\t\t\t\tpoints[leftIdx],\n\t\t\t\tpoints[rightIdx],\n\t\t\t\texternalForce,\n\t\t\t\tdt\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * Apply an impulse to control points (for collisions, bounces)\n\t *\n\t * @param points - Control points array\n\t * @param velocities - Velocities array\n\t * @param impulseDirection - Angle of impulse (radians)\n\t * @param impulseMagnitude - Strength of impulse\n\t */\n\tapplyImpulse(\n\t\tpoints: ControlPoint[],\n\t\tvelocities: ControlPointVelocity[],\n\t\timpulseDirection: number,\n\t\timpulseMagnitude: number\n\t): void {\n\t\tfor (let i = 0; i < points.length; i++) {\n\t\t\tconst point = points[i];\n\t\t\tconst velocity = velocities[i];\n\n\t\t\t// Calculate how aligned this point is with the impulse direction\n\t\t\tconst alignment = Math.cos(point.angle - impulseDirection);\n\n\t\t\t// Points in the direction of impulse get compressed\n\t\t\t// Points opposite get expanded\n\t\t\tvelocity.radialVelocity -= alignment * impulseMagnitude;\n\t\t}\n\t}\n\n\t/**\n\t * Apply pressure change to all points (for blob-blob interaction)\n\t *\n\t * @param velocities - Velocities array\n\t * @param pressureChange - Amount to change pressure (-1 to 1)\n\t */\n\tapplyPressure(velocities: ControlPointVelocity[], pressureChange: number): void {\n\t\tfor (const velocity of velocities) {\n\t\t\tvelocity.radialVelocity += pressureChange * 0.1;\n\t\t}\n\t}\n\n\t/**\n\t * Get total kinetic energy of control points (for debugging)\n\t */\n\tgetKineticEnergy(velocities: ControlPointVelocity[]): number {\n\t\tlet energy = 0;\n\t\tfor (const v of velocities) {\n\t\t\tenergy += 0.5 * v.radialVelocity * v.radialVelocity;\n\t\t}\n\t\treturn energy;\n\t}\n\n\t/**\n\t * Get total potential energy (spring displacement)\n\t */\n\tgetPotentialEnergy(points: ControlPoint[]): number {\n\t\tlet energy = 0;\n\t\tfor (const p of points) {\n\t\t\tconst displacement = p.radius - p.baseRadius;\n\t\t\tenergy += 0.5 * this.config.springConstant * displacement * displacement;\n\t\t}\n\t\treturn energy;\n\t}\n\n\t/**\n\t * Check if system is at rest (low energy)\n\t */\n\tisAtRest(points: ControlPoint[], velocities: ControlPointVelocity[], threshold: number = 0.001): boolean {\n\t\tconst ke = this.getKineticEnergy(velocities);\n\t\tconst pe = this.getPotentialEnergy(points);\n\t\treturn ke + pe < threshold;\n\t}\n\n\t/**\n\t * Update configuration\n\t */\n\tsetConfig(config: Partial<SpringConfig>): void {\n\t\tthis.config = { ...this.config, ...config };\n\t}\n\n\t/**\n\t * Get current configuration\n\t */\n\tgetConfig(): SpringConfig {\n\t\treturn { ...this.config };\n\t}\n}\n\n/**\n * Create control point velocities for a new blob\n */\nexport function createControlPointVelocities(count: number): ControlPointVelocity[] {\n\tconst velocities: ControlPointVelocity[] = [];\n\tfor (let i = 0; i < count; i++) {\n\t\tvelocities.push({\n\t\t\tradialVelocity: 0,\n\t\t\tangularVelocity: (Math.random() - 0.5) * 0.0004,\n\t\t\tpressureVelocity: 0,\n\t\t});\n\t}\n\treturn velocities;\n}\n\n/**\n * Compute polygon area from control points (for area conservation)\n * Uses Shoelace formula\n */\nexport function computePolygonArea(points: ControlPoint[]): number {\n\tif (points.length < 3) return 0;\n\n\tlet area = 0;\n\tconst n = points.length;\n\n\tfor (let i = 0; i < n; i++) {\n\t\tconst p1 = points[i];\n\t\tconst p2 = points[(i + 1) % n];\n\n\t\t// Convert polar to cartesian (relative to center)\n\t\tconst x1 = Math.cos(p1.angle) * p1.radius;\n\t\tconst y1 = Math.sin(p1.angle) * p1.radius;\n\t\tconst x2 = Math.cos(p2.angle) * p2.radius;\n\t\tconst y2 = Math.sin(p2.angle) * p2.radius;\n\n\t\tarea += x1 * y2 - x2 * y1;\n\t}\n\n\treturn Math.abs(area) / 2;\n}\n\n/**\n * Enforce area conservation by scaling all radii\n */\nexport function enforceAreaConservation(\n\tpoints: ControlPoint[],\n\ttargetArea: number,\n\ttolerance: number = 0.05\n): void {\n\tconst currentArea = computePolygonArea(points);\n\tconst areaRatio = currentArea / targetArea;\n\n\tif (Math.abs(areaRatio - 1) > tolerance) {\n\t\tconst scaleFactor = Math.sqrt(1 / areaRatio);\n\n\t\tfor (const point of points) {\n\t\t\tpoint.radius *= scaleFactor;\n\t\t}\n\t}\n}\n\n/**\n * Compute circularity metric (1.0 = perfect circle, lower = more irregular)\n */\nexport function computeCircularity(points: ControlPoint[]): number {\n\tif (points.length === 0) return 1.0;\n\n\t// Compute mean radius\n\tlet sumRadius = 0;\n\tfor (const p of points) {\n\t\tsumRadius += p.radius;\n\t}\n\tconst meanRadius = sumRadius / points.length;\n\n\t// Compute variance\n\tlet variance = 0;\n\tfor (const p of points) {\n\t\tconst diff = p.radius - meanRadius;\n\t\tvariance += diff * diff;\n\t}\n\tvariance /= points.length;\n\n\t// Circularity = 1 / (1 + coefficient of variation)\n\tconst stdDev = Math.sqrt(variance);\n\tconst cv = stdDev / meanRadius;\n\n\treturn 1 / (1 + cv * 5); // Scale factor for sensitivity\n}\n"],"mappings":"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"}