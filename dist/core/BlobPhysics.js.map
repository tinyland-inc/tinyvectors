{"version":3,"file":"BlobPhysics.js","names":["DEFAULT_CONFIG: BlobPhysicsConfig","externalForces: number[]","hull: Array<{ x: number; y: number }>"],"sources":["../../src/core/BlobPhysics.ts"],"sourcesContent":["/**\n * TinyVectors Full Gel Physics Simulation\n *\n * Complete physics engine with:\n * - Anti-clustering system (now O(n) with SpatialHash)\n * - Territorial movement\n * - Accelerometer forces\n * - Brownian motion\n * - Organic control point deformation (spring-damper system)\n * - Gaussian kernel smoothing\n * - Wall bouncing with chaos injection\n * - Convex hull path generation\n */\n\nimport type { ConvexBlob, GravityVector, TiltVector } from './types.js';\nimport { SpatialHash } from './SpatialHash.js';\nimport { GaussianKernel } from './GaussianKernel.js';\nimport { SpringSystem, DEFAULT_SPRING_CONFIG, type SpringConfig } from './SpringSystem.js';\n\nexport interface BlobPhysicsConfig {\n\tantiClusteringStrength: number;\n\tbounceDamping: number;\n\tdeformationSpeed: number;\n\tterritoryStrength: number;\n\tviscosity: number;\n\t/** Use spatial hash for O(n) collision detection */\n\tuseSpatialHash: boolean;\n\t/** Use Gaussian kernel for smoothing */\n\tuseGaussianSmoothing: boolean;\n\t/** Use spring system for deformation */\n\tuseSpringSystem: boolean;\n\t/** Spring system configuration */\n\tspringConfig: Partial<SpringConfig>;\n}\n\nconst DEFAULT_CONFIG: BlobPhysicsConfig = {\n\tantiClusteringStrength: 0.15,\n\tbounceDamping: 0.7,\n\tdeformationSpeed: 0.5,\n\tterritoryStrength: 0.1,\n\tviscosity: 0.3,\n\tuseSpatialHash: true,\n\tuseGaussianSmoothing: true,\n\tuseSpringSystem: true,\n\tspringConfig: {},\n};\n\nexport class BlobPhysics {\n\tprivate blobs: ConvexBlob[] = [];\n\tprivate config: BlobPhysicsConfig;\n\tprivate numBlobs: number;\n\tprivate initialized = false;\n\n\t// Mouse state\n\tprivate mouseX = 50;\n\tprivate mouseY = 50;\n\tprivate mouseVelX = 0;\n\tprivate mouseVelY = 0;\n\tprivate lastMouseX = 50;\n\tprivate lastMouseY = 50;\n\n\t// Physics state\n\tprivate gravity: GravityVector = { x: 0, y: 0 };\n\tprivate tilt: TiltVector = { x: 0, y: 0, z: 0 };\n\tprivate scrollStickiness = 0;\n\n\t// Extended physics bounds - allows blobs to extend beyond visible area\n\tprivate readonly PHYSICS_MIN = -40;\n\tprivate readonly PHYSICS_MAX = 140;\n\n\t// New physics components\n\tprivate spatialHash: SpatialHash;\n\tprivate gaussianKernel: GaussianKernel;\n\tprivate springSystem: SpringSystem;\n\n\tconstructor(numBlobs: number, config: Partial<BlobPhysicsConfig> = {}) {\n\t\tthis.numBlobs = numBlobs;\n\t\tthis.config = { ...DEFAULT_CONFIG, ...config };\n\n\t\t// Initialize new physics components\n\t\tthis.spatialHash = new SpatialHash(60); // Cell size ~2x personal space\n\t\tthis.gaussianKernel = new GaussianKernel(5, 1.2);\n\t\tthis.springSystem = new SpringSystem({\n\t\t\t...DEFAULT_SPRING_CONFIG,\n\t\t\t...this.config.springConfig,\n\t\t});\n\t}\n\n\t/**\n\t * Initialize physics - creates blobs\n\t */\n\tasync init(): Promise<void> {\n\t\tif (this.initialized) return;\n\t\tthis.initializeBlobs();\n\t\tthis.initialized = true;\n\t}\n\n\t/**\n\t * Check if physics is ready\n\t */\n\tisReady(): boolean {\n\t\treturn this.initialized;\n\t}\n\n\t/**\n\t * Cleanup resources\n\t */\n\tdispose(): void {\n\t\tthis.blobs = [];\n\t\tthis.initialized = false;\n\t}\n\n\t/**\n\t * Update accelerometer/gravity data\n\t */\n\tsetGravity(gravity: GravityVector): void {\n\t\tthis.gravity = gravity;\n\t}\n\n\t/**\n\t * Update tilt data\n\t */\n\tsetTilt(tilt: TiltVector): void {\n\t\tthis.tilt = tilt;\n\t}\n\n\t/**\n\t * Update scroll stickiness\n\t */\n\tsetScrollStickiness(value: number): void {\n\t\tthis.scrollStickiness = value;\n\t}\n\n\t/**\n\t * Main physics tick - updates all blobs\n\t */\n\ttick(deltaTime: number, time: number): void {\n\t\tif (!this.initialized) return;\n\n\t\t// Rebuild spatial hash for this frame (if enabled)\n\t\tif (this.config.useSpatialHash) {\n\t\t\tthis.spatialHash.rebuild(this.blobs);\n\t\t}\n\n\t\t// Apply anti-clustering forces first\n\t\tif (this.config.useSpatialHash) {\n\t\t\tthis.applyAntiClusteringWithSpatialHash();\n\t\t} else {\n\t\t\tthis.applyEnhancedAntiClustering();\n\t\t}\n\n\t\t// Update each blob\n\t\tthis.blobs.forEach((blob) =>\n\t\t\tthis.updateScreensaverPhysics(blob, deltaTime, time)\n\t\t);\n\n\t\t// Decay mouse velocity\n\t\tthis.mouseVelX *= 0.96;\n\t\tthis.mouseVelY *= 0.96;\n\t}\n\n\t/**\n\t * Apply anti-clustering using spatial hash (O(n) average case)\n\t */\n\tprivate applyAntiClusteringWithSpatialHash(): void {\n\t\tconst maxPersonalSpace = 60; // Max query radius\n\n\t\tfor (const blob of this.blobs) {\n\t\t\tconst neighbors = this.spatialHash.queryNeighbors(blob, maxPersonalSpace);\n\n\t\t\tfor (const other of neighbors) {\n\t\t\t\tconst dx = other.currentX - blob.currentX;\n\t\t\t\tconst dy = other.currentY - blob.currentY;\n\t\t\t\tconst distance = Math.sqrt(dx * dx + dy * dy);\n\n\t\t\t\tconst requiredDistance = Math.max(blob.personalSpace || 50, other.personalSpace || 50);\n\n\t\t\t\tif (distance < requiredDistance && distance > 0) {\n\t\t\t\t\tconst overlap = requiredDistance - distance;\n\t\t\t\t\tconst repulsionForce = (overlap / requiredDistance) * 0.055 * this.config.antiClusteringStrength / 0.15;\n\n\t\t\t\t\tconst normalizedDx = dx / distance;\n\t\t\t\t\tconst normalizedDy = dy / distance;\n\n\t\t\t\t\tconst forceMultiplier = blob.repulsionStrength || 0.03;\n\t\t\t\t\tconst proximityMultiplier = distance < requiredDistance * 0.7 ? 3.5 : 1.0;\n\n\t\t\t\t\t// Only apply to current blob (other will get its turn)\n\t\t\t\t\tblob.velocityX -= normalizedDx * repulsionForce * forceMultiplier * proximityMultiplier * 0.5;\n\t\t\t\t\tblob.velocityY -= normalizedDy * repulsionForce * forceMultiplier * proximityMultiplier * 0.5;\n\n\t\t\t\t\tblob.lastRepulsionTime = Date.now();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Update mouse position for interactions\n\t */\n\tupdateMousePosition(x: number, y: number): void {\n\t\tthis.mouseVelX = x - this.lastMouseX;\n\t\tthis.mouseVelY = y - this.lastMouseY;\n\t\tthis.lastMouseX = this.mouseX;\n\t\tthis.lastMouseY = this.mouseY;\n\t\tthis.mouseX = x;\n\t\tthis.mouseY = y;\n\t}\n\n\t/**\n\t * Get blobs for rendering\n\t */\n\tgetBlobs(themeColors?: string[]): ConvexBlob[] {\n\t\tif (themeColors && themeColors.length > 0) {\n\t\t\t// Apply theme colors to blobs\n\t\t\treturn this.blobs.map((blob, i) => ({\n\t\t\t\t...blob,\n\t\t\t\tcolor: themeColors[i % themeColors.length],\n\t\t\t}));\n\t\t}\n\t\treturn this.blobs;\n\t}\n\n\t/**\n\t * Generate smooth SVG path for organic blob shape\n\t */\n\tgenerateSmoothBlobPath(blob: ConvexBlob): string {\n\t\tif (!blob.controlPoints || blob.controlPoints.length < 3) {\n\t\t\t// Fallback to circle\n\t\t\tconst displayX = blob.currentX;\n\t\t\tconst displayY = blob.currentY;\n\t\t\tconst displaySize = blob.size;\n\n\t\t\treturn `M ${displayX - displaySize},${displayY}\n\t\t\t\t\tA ${displaySize},${displaySize} 0 1,1 ${displayX + displaySize},${displayY}\n\t\t\t\t\tA ${displaySize},${displaySize} 0 1,1 ${displayX - displaySize},${displayY}`;\n\t\t}\n\n\t\tconst displayX = blob.currentX;\n\t\tconst displayY = blob.currentY;\n\n\t\t// Generate points from control points\n\t\tconst points = blob.controlPoints.map((point) => {\n\t\t\tconst x = displayX + Math.cos(point.angle) * point.radius;\n\t\t\tconst y = displayY + Math.sin(point.angle) * point.radius;\n\t\t\treturn { x, y };\n\t\t});\n\n\t\t// Apply convex hull to prevent self-intersection\n\t\tconst convexPoints = this.generateConvexHull(points);\n\n\t\t// Build smooth curved path\n\t\tlet path = `M ${convexPoints[0].x.toFixed(2)},${convexPoints[0].y.toFixed(2)}`;\n\n\t\tfor (let i = 0; i < convexPoints.length; i++) {\n\t\t\tconst current = convexPoints[i];\n\t\t\tconst next = convexPoints[(i + 1) % convexPoints.length];\n\t\t\tconst nextNext = convexPoints[(i + 2) % convexPoints.length];\n\n\t\t\t// Conservative control points for smooth curves\n\t\t\tconst cp1x = current.x + (next.x - current.x) * 0.15;\n\t\t\tconst cp1y = current.y + (next.y - current.y) * 0.15;\n\t\t\tconst cp2x = next.x - (nextNext.x - current.x) * 0.05;\n\t\t\tconst cp2y = next.y - (nextNext.y - current.y) * 0.05;\n\n\t\t\tpath += ` C ${cp1x.toFixed(2)},${cp1y.toFixed(2)} ${cp2x.toFixed(2)},${cp2y.toFixed(2)} ${next.x.toFixed(2)},${next.y.toFixed(2)}`;\n\t\t}\n\n\t\tpath += ' Z';\n\t\treturn path;\n\t}\n\n\t// ============================================================================\n\t// PRIVATE METHODS\n\t// ============================================================================\n\n\tprivate initializeBlobs(): void {\n\t\tthis.blobs = [];\n\n\t\tfor (let i = 0; i < this.numBlobs; i++) {\n\t\t\t// Spread blobs across the FULL viewBox using grid-like distribution\n\t\t\tconst cols = Math.ceil(Math.sqrt(this.numBlobs));\n\t\t\tconst rows = Math.ceil(this.numBlobs / cols);\n\t\t\tconst col = i % cols;\n\t\t\tconst row = Math.floor(i / cols);\n\n\t\t\t// Use full physics bounds with margin\n\t\t\tconst cellWidth = (this.PHYSICS_MAX - this.PHYSICS_MIN - 40) / cols;\n\t\t\tconst cellHeight = (this.PHYSICS_MAX - this.PHYSICS_MIN - 40) / rows;\n\n\t\t\t// Position with jitter for organic feel\n\t\t\tconst baseX = this.PHYSICS_MIN + 20 + col * cellWidth + cellWidth / 2 + (Math.random() - 0.5) * cellWidth * 0.5;\n\t\t\tconst baseY = this.PHYSICS_MIN + 20 + row * cellHeight + cellHeight / 2 + (Math.random() - 0.5) * cellHeight * 0.5;\n\n\t\t\t// Clamp to physics bounds\n\t\t\tconst clampedX = Math.max(this.PHYSICS_MIN + 20, Math.min(this.PHYSICS_MAX - 20, baseX));\n\t\t\tconst clampedY = Math.max(this.PHYSICS_MIN + 20, Math.min(this.PHYSICS_MAX - 20, baseY));\n\n\t\t\t// Smaller blob sizes for better spread\n\t\t\tconst baseSize = 15 + Math.random() * 12;\n\n\t\t\t// Reduced control points for performance (8 instead of 16)\n\t\t\tconst numControlPoints = 8;\n\t\t\tconst controlPoints = [];\n\t\t\tconst controlVelocities = [];\n\n\t\t\tfor (let j = 0; j < numControlPoints; j++) {\n\t\t\t\tconst pointAngle = (j / numControlPoints) * Math.PI * 2;\n\t\t\t\tconst radiusVariation = 0.8 + Math.random() * 0.35;\n\t\t\t\tconst pointRadius = baseSize * radiusVariation;\n\n\t\t\t\tcontrolPoints.push({\n\t\t\t\t\tradius: pointRadius,\n\t\t\t\t\tangle: pointAngle,\n\t\t\t\t\ttargetRadius: pointRadius,\n\t\t\t\t\tbaseRadius: pointRadius,\n\t\t\t\t\tpressure: 1.0,\n\t\t\t\t\tadhesion: 0.15 + Math.random() * 0.1,\n\t\t\t\t\ttension: 0.3 + Math.random() * 0.15,\n\t\t\t\t});\n\n\t\t\t\tcontrolVelocities.push({\n\t\t\t\t\tradialVelocity: 0,\n\t\t\t\t\tangularVelocity: (Math.random() - 0.5) * 0.0004,\n\t\t\t\t\tpressureVelocity: 0,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis.blobs.push({\n\t\t\t\tbaseX: clampedX,\n\t\t\t\tbaseY: clampedY,\n\t\t\t\tcurrentX: clampedX,\n\t\t\t\tcurrentY: clampedY,\n\t\t\t\tvelocityX: (Math.random() - 0.5) * 0.02,\n\t\t\t\tvelocityY: (Math.random() - 0.5) * 0.02,\n\t\t\t\tsize: baseSize,\n\t\t\t\telasticity: 0.0004 + Math.random() * 0.0002,\n\t\t\t\tviscosity: 0.995 + Math.random() * 0.003,\n\t\t\t\tphase: Math.random() * Math.PI * 2,\n\t\t\t\tspeed: 0.003 + Math.random() * 0.002,\n\t\t\t\tcolor: `hsl(${(i * 30) % 360}, 70%, 60%)`,\n\t\t\t\tgradientId: `blob-gradient-${i}`,\n\t\t\t\tintensity: 0.65 + Math.random() * 0.2,\n\t\t\t\tstickiness: 2,\n\t\t\t\tisAttractive: i % 2 === 0,\n\t\t\t\tmouseDistance: 100,\n\t\t\t\tisStuck: false,\n\t\t\t\tradiusVariations: [],\n\t\t\t\tfluidMass: 0.5 + Math.random() * 0.25,\n\t\t\t\tscrollAffinity: 0.3 + Math.random() * 0.5,\n\t\t\t\tsurfaceTension: 0.02 + Math.random() * 0.01,\n\t\t\t\tdensity: 0.4 + Math.random() * 0.1,\n\t\t\t\tflowResistance: 0.002 + Math.random() * 0.001,\n\t\t\t\tcontrolPoints,\n\t\t\t\tcontrolVelocities,\n\t\t\t\tdeformationStrength: 0.3 + Math.random() * 0.15,\n\t\t\t\tcohesion: 0.05 + Math.random() * 0.03,\n\t\t\t\tstretchability: 0.8 + Math.random() * 0.3,\n\t\t\t\tlastCollisionTime: 0,\n\t\t\t\tmergeThreshold: baseSize * 0.5,\n\t\t\t\tsplitThreshold: baseSize * 1.5,\n\t\t\t\tisSettled: false,\n\t\t\t\tsettleTime: 0,\n\t\t\t\tgroundContactPoints: [],\n\t\t\t\trestHeight: baseSize * 0.7,\n\t\t\t\twetting: 0.15 + Math.random() * 0.1,\n\t\t\t\tcontactAngle: 70 + Math.random() * 30,\n\t\t\t\tpressureDistribution: new Array(numControlPoints).fill(1.0),\n\t\t\t\tchaosLevel: 0,\n\t\t\t\tturbulenceDecay: 0.985,\n\t\t\t\texpansionPhase: false,\n\t\t\t\texpansionTime: 0,\n\t\t\t\tmaxExpansionTime: 20 + Math.random() * 40,\n\t\t\t\twallBounceCount: 0,\n\t\t\t\tlastBounceTime: 0,\n\t\t\t\tdriftAngle: Math.random() * Math.PI * 2,\n\t\t\t\tdriftSpeed: 0.01 + Math.random() * 0.015,\n\t\t\t\tterritoryRadius: 100 + Math.random() * 60,\n\t\t\t\tterritoryX: clampedX,\n\t\t\t\tterritoryY: clampedY,\n\t\t\t\tpersonalSpace: 35 + Math.random() * 20,\n\t\t\t\trepulsionStrength: 0.025 + Math.random() * 0.015,\n\t\t\t\tlastRepulsionTime: 0,\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate applyEnhancedAntiClustering(): void {\n\t\tfor (let i = 0; i < this.blobs.length; i++) {\n\t\t\tconst blob1 = this.blobs[i];\n\n\t\t\tfor (let j = i + 1; j < this.blobs.length; j++) {\n\t\t\t\tconst blob2 = this.blobs[j];\n\n\t\t\t\tconst dx = blob2.currentX - blob1.currentX;\n\t\t\t\tconst dy = blob2.currentY - blob1.currentY;\n\t\t\t\tconst distance = Math.sqrt(dx * dx + dy * dy);\n\n\t\t\t\tconst requiredDistance = Math.max(blob1.personalSpace || 50, blob2.personalSpace || 50);\n\n\t\t\t\tif (distance < requiredDistance && distance > 0) {\n\t\t\t\t\tconst overlap = requiredDistance - distance;\n\t\t\t\t\tconst repulsionForce = (overlap / requiredDistance) * 0.055 * this.config.antiClusteringStrength / 0.15;\n\n\t\t\t\t\tconst normalizedDx = dx / distance;\n\t\t\t\t\tconst normalizedDy = dy / distance;\n\n\t\t\t\t\tconst force1Multiplier = blob1.repulsionStrength || 0.03;\n\t\t\t\t\tconst force2Multiplier = blob2.repulsionStrength || 0.03;\n\n\t\t\t\t\t// Stronger repulsion when very close\n\t\t\t\t\tconst proximityMultiplier = distance < requiredDistance * 0.7 ? 3.5 : 1.0;\n\n\t\t\t\t\tblob1.velocityX -= normalizedDx * repulsionForce * force1Multiplier * proximityMultiplier;\n\t\t\t\t\tblob1.velocityY -= normalizedDy * repulsionForce * force1Multiplier * proximityMultiplier;\n\n\t\t\t\t\tblob2.velocityX += normalizedDx * repulsionForce * force2Multiplier * proximityMultiplier;\n\t\t\t\t\tblob2.velocityY += normalizedDy * repulsionForce * force2Multiplier * proximityMultiplier;\n\n\t\t\t\t\tblob1.lastRepulsionTime = Date.now();\n\t\t\t\t\tblob2.lastRepulsionTime = Date.now();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate updateScreensaverPhysics(blob: ConvexBlob, deltaTime: number, time: number): void {\n\t\t// Calculate mouse distance\n\t\tblob.mouseDistance = Math.sqrt(\n\t\t\tMath.pow(blob.currentX - this.mouseX, 2) + Math.pow(blob.currentY - this.mouseY, 2)\n\t\t);\n\n\t\t// Territorial movement\n\t\tthis.updateTerritorialMovement(blob, time);\n\n\t\t// Apply accelerometer forces\n\t\tthis.applyAccelerometerForces(blob);\n\n\t\t// Movement with brownian motion\n\t\tthis.updateMovementWithAccelerometer(blob, time);\n\n\t\t// Escape velocity after repulsion\n\t\tthis.addEscapeVelocity(blob);\n\n\t\t// Organic deformation\n\t\tthis.updateSafeOrganicDeformation(blob, time);\n\n\t\t// Scroll effects\n\t\tif (this.scrollStickiness > 0.01) {\n\t\t\tthis.applyScrollEffect(blob);\n\t\t}\n\n\t\t// Update position\n\t\tblob.currentX += blob.velocityX;\n\t\tblob.currentY += blob.velocityY;\n\n\t\t// Wall bouncing\n\t\tthis.handleWallBouncing(blob);\n\n\t\t// Apply friction\n\t\tblob.velocityX *= 0.992;\n\t\tblob.velocityY *= 0.992;\n\t}\n\n\tprivate applyAccelerometerForces(blob: ConvexBlob): void {\n\t\tconst accelerometerStrength = 0.0008;\n\t\tconst maxForce = 0.003;\n\n\t\tconst gravityX = Math.max(-maxForce, Math.min(maxForce, this.gravity.x * accelerometerStrength));\n\t\tconst gravityY = Math.max(-maxForce, Math.min(maxForce, this.gravity.y * accelerometerStrength));\n\n\t\tblob.velocityX += gravityX;\n\t\tblob.velocityY += gravityY;\n\n\t\t// Shape deformation from acceleration\n\t\tif (blob.controlPoints && (Math.abs(this.gravity.x) > 0.3 || Math.abs(this.gravity.y) > 0.3)) {\n\t\t\tconst deformationAmount = Math.min(0.08, (Math.abs(this.gravity.x) + Math.abs(this.gravity.y)) * 0.02);\n\t\t\tblob.chaosLevel = Math.min((blob.chaosLevel || 0) + deformationAmount, 0.2);\n\t\t}\n\t}\n\n\tprivate updateMovementWithAccelerometer(blob: ConvexBlob, time: number): void {\n\t\t// Random drift\n\t\tconst neutralDriftX = (Math.random() - 0.5) * 0.001;\n\t\tconst neutralDriftY = (Math.random() - 0.5) * 0.001;\n\n\t\tblob.velocityX += neutralDriftX;\n\t\tblob.velocityY += neutralDriftY;\n\n\t\t// Brownian motion\n\t\tconst brownianTime = time * 0.1 + blob.phase;\n\t\tconst brownianX = Math.sin(brownianTime + (blob.driftAngle || 0)) * 0.0005;\n\t\tconst brownianY = Math.cos(brownianTime * 1.3 + (blob.driftAngle || 0)) * 0.0005;\n\n\t\tblob.velocityX += brownianX;\n\t\tblob.velocityY += brownianY;\n\n\t\t// Random drift direction change\n\t\tif (Math.random() < 0.002) {\n\t\t\tblob.driftAngle = Math.random() * Math.PI * 2;\n\t\t}\n\t}\n\n\tprivate updateTerritorialMovement(blob: ConvexBlob, time: number): void {\n\t\tconst territoryX = blob.territoryX || blob.baseX;\n\t\tconst territoryY = blob.territoryY || blob.baseY;\n\t\tconst territoryRadius = blob.territoryRadius || 70;\n\n\t\tconst distanceFromTerritory = Math.sqrt(\n\t\t\tMath.pow(blob.currentX - territoryX, 2) + Math.pow(blob.currentY - territoryY, 2)\n\t\t);\n\n\t\t// Gentle pull back to territory\n\t\tif (distanceFromTerritory > territoryRadius) {\n\t\t\tconst pullStrength = ((distanceFromTerritory - territoryRadius) / territoryRadius) * 0.0002 * this.config.territoryStrength / 0.1;\n\t\t\tconst angleToTerritory = Math.atan2(territoryY - blob.currentY, territoryX - blob.currentX);\n\n\t\t\tblob.velocityX += Math.cos(angleToTerritory) * pullStrength;\n\t\t\tblob.velocityY += Math.sin(angleToTerritory) * pullStrength;\n\t\t}\n\n\t\t// Random drift\n\t\tblob.velocityX += (Math.random() - 0.5) * 0.003;\n\t\tblob.velocityY += (Math.random() - 0.5) * 0.003;\n\n\t\t// Periodic territory relocation\n\t\tif (time % 45 < 0.1) {\n\t\t\tconst randomOffset = 35;\n\t\t\tblob.territoryX = Math.max(\n\t\t\t\tthis.PHYSICS_MIN + 35,\n\t\t\t\tMath.min(this.PHYSICS_MAX - 35, territoryX + (Math.random() - 0.5) * randomOffset)\n\t\t\t);\n\t\t\tblob.territoryY = Math.max(\n\t\t\t\tthis.PHYSICS_MIN + 35,\n\t\t\t\tMath.min(this.PHYSICS_MAX - 35, territoryY + (Math.random() - 0.5) * randomOffset)\n\t\t\t);\n\t\t}\n\t}\n\n\tprivate addEscapeVelocity(blob: ConvexBlob): void {\n\t\tif (blob.lastRepulsionTime && Date.now() - blob.lastRepulsionTime < 3000) {\n\t\t\tconst escapeStrength = 0.01;\n\t\t\tconst escapeAngle = Math.random() * Math.PI * 2;\n\n\t\t\tblob.velocityX += Math.cos(escapeAngle) * escapeStrength;\n\t\t\tblob.velocityY += Math.sin(escapeAngle) * escapeStrength;\n\t\t}\n\t}\n\n\tprivate updateSafeOrganicDeformation(blob: ConvexBlob, time: number): void {\n\t\tif (!blob.controlPoints || !blob.controlVelocities) return;\n\n\t\tif (this.config.useSpringSystem) {\n\t\t\t// Use spring system for physically-based deformation\n\t\t\tthis.updateSpringDeformation(blob, time);\n\t\t} else {\n\t\t\t// Fallback to sinusoidal deformation\n\t\t\tthis.updateSinusoidalDeformation(blob, time);\n\t\t}\n\n\t\t// Smoothing pass\n\t\tif (this.config.useGaussianSmoothing) {\n\t\t\tthis.gaussianKernel.convolve(blob.controlPoints);\n\t\t} else {\n\t\t\tthis.smoothControlPoints(blob);\n\t\t}\n\t}\n\n\t/**\n\t * Spring-based deformation (physically-based gel simulation)\n\t */\n\tprivate updateSpringDeformation(blob: ConvexBlob, time: number): void {\n\t\tif (!blob.controlPoints || !blob.controlVelocities) return;\n\n\t\t// Compute external force from blob velocity (inertial effects)\n\t\tconst velocityMag = Math.sqrt(blob.velocityX * blob.velocityX + blob.velocityY * blob.velocityY);\n\t\tconst velocityAngle = Math.atan2(blob.velocityY, blob.velocityX);\n\n\t\t// Per-point external forces based on velocity direction\n\t\tconst externalForces: number[] = blob.controlPoints.map((point) => {\n\t\t\t// Points in the direction of motion get compressed\n\t\t\tconst alignment = Math.cos(point.angle - velocityAngle);\n\t\t\treturn -alignment * velocityMag * 0.5;\n\t\t});\n\n\t\t// Add chaos/turbulence as random forces\n\t\tif (blob.chaosLevel && blob.chaosLevel > 0.01) {\n\t\t\tfor (let i = 0; i < externalForces.length; i++) {\n\t\t\t\texternalForces[i] += (Math.random() - 0.5) * blob.chaosLevel * 0.3;\n\t\t\t}\n\t\t}\n\n\t\t// Update spring system\n\t\tthis.springSystem.updateAllControlPoints(\n\t\t\tblob.controlPoints,\n\t\t\tblob.controlVelocities,\n\t\t\texternalForces,\n\t\t\t0.016 // Fixed dt for stability\n\t\t);\n\n\t\t// Update angles (slow rotation)\n\t\tfor (let i = 0; i < blob.controlPoints.length; i++) {\n\t\t\tconst velocity = blob.controlVelocities[i];\n\t\t\tvelocity.angularVelocity += (Math.random() - 0.5) * 0.00002;\n\t\t\tvelocity.angularVelocity *= 0.998;\n\t\t\tvelocity.angularVelocity = Math.max(-0.0006, Math.min(0.0006, velocity.angularVelocity));\n\t\t\tblob.controlPoints[i].angle += velocity.angularVelocity;\n\t\t}\n\n\t\t// Decay chaos level\n\t\tif (blob.chaosLevel) {\n\t\t\tblob.chaosLevel *= blob.turbulenceDecay || 0.985;\n\t\t}\n\t}\n\n\t/**\n\t * Sinusoidal deformation (fallback, decorative only)\n\t */\n\tprivate updateSinusoidalDeformation(blob: ConvexBlob, time: number): void {\n\t\tif (!blob.controlPoints || !blob.controlVelocities) return;\n\n\t\tblob.controlPoints.forEach((point, i) => {\n\t\t\t// Controlled organic pulsing\n\t\t\tconst pulseTime = time * 0.15 * this.config.deformationSpeed / 0.5 + i * 0.4 + blob.phase;\n\t\t\tconst pulseAmount = Math.sin(pulseTime) * 0.02;\n\n\t\t\t// Enforce min/max radius\n\t\t\tconst minRadius = point.baseRadius * 0.85;\n\t\t\tconst maxRadius = point.baseRadius * 1.15;\n\n\t\t\tconst targetRadius = point.baseRadius * (1 + pulseAmount);\n\t\t\tpoint.targetRadius = Math.max(minRadius, Math.min(maxRadius, targetRadius));\n\n\t\t\t// Smooth radius transition\n\t\t\tconst radiusDiff = point.targetRadius - point.radius;\n\t\t\tpoint.radius += radiusDiff * 0.008;\n\n\t\t\t// Controlled rotation\n\t\t\tif (blob.controlVelocities && blob.controlVelocities[i]) {\n\t\t\t\tblob.controlVelocities[i].angularVelocity += (Math.random() - 0.5) * 0.00003;\n\t\t\t\tblob.controlVelocities[i].angularVelocity *= 0.999;\n\t\t\t\tblob.controlVelocities[i].angularVelocity = Math.max(\n\t\t\t\t\t-0.0008,\n\t\t\t\t\tMath.min(0.0008, blob.controlVelocities[i].angularVelocity)\n\t\t\t\t);\n\t\t\t\tpoint.angle += blob.controlVelocities[i].angularVelocity;\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate smoothControlPoints(blob: ConvexBlob): void {\n\t\tif (!blob.controlPoints || blob.controlPoints.length < 3) return;\n\n\t\tfor (let i = 0; i < blob.controlPoints.length; i++) {\n\t\t\tconst current = blob.controlPoints[i];\n\t\t\tconst prev = blob.controlPoints[(i - 1 + blob.controlPoints.length) % blob.controlPoints.length];\n\t\t\tconst next = blob.controlPoints[(i + 1) % blob.controlPoints.length];\n\n\t\t\t// Smooth radius variations\n\t\t\tconst avgRadius = (prev.radius + current.radius + next.radius) / 3;\n\t\t\tconst smoothingFactor = 0.05;\n\t\t\tcurrent.radius = current.radius * (1 - smoothingFactor) + avgRadius * smoothingFactor;\n\n\t\t\t// Prevent sharp transitions\n\t\t\tconst minRadiusDiff = blob.size * 0.1;\n\t\t\tif (Math.abs(current.radius - prev.radius) > minRadiusDiff) {\n\t\t\t\tconst adjustment = (Math.abs(current.radius - prev.radius) - minRadiusDiff) * 0.5;\n\t\t\t\tif (current.radius > prev.radius) {\n\t\t\t\t\tcurrent.radius -= adjustment;\n\t\t\t\t\tprev.radius += adjustment;\n\t\t\t\t} else {\n\t\t\t\t\tcurrent.radius += adjustment;\n\t\t\t\t\tprev.radius -= adjustment;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate applyScrollEffect(blob: ConvexBlob): void {\n\t\tconst attractionStrength = this.scrollStickiness * blob.scrollAffinity * 0.0002;\n\t\tblob.velocityX += (this.mouseX - blob.currentX) * attractionStrength;\n\t\tblob.velocityY += (this.mouseY - blob.currentY) * attractionStrength;\n\n\t\tif (this.scrollStickiness > 0.15) {\n\t\t\tblob.chaosLevel = Math.min((blob.chaosLevel || 0) + this.scrollStickiness * 0.02, 0.15);\n\t\t}\n\t}\n\n\tprivate handleWallBouncing(blob: ConvexBlob): void {\n\t\tconst margin = blob.size * 0.8;\n\t\tconst damping = this.config.bounceDamping;\n\t\tconst currentTime = Date.now();\n\n\t\t// Left wall\n\t\tif (blob.currentX < this.PHYSICS_MIN + margin) {\n\t\t\tblob.currentX = this.PHYSICS_MIN + margin;\n\t\t\tblob.velocityX = Math.abs(blob.velocityX) * damping;\n\t\t\tthis.recordBounce(blob, currentTime);\n\t\t}\n\n\t\t// Right wall\n\t\tif (blob.currentX > this.PHYSICS_MAX - margin) {\n\t\t\tblob.currentX = this.PHYSICS_MAX - margin;\n\t\t\tblob.velocityX = -Math.abs(blob.velocityX) * damping;\n\t\t\tthis.recordBounce(blob, currentTime);\n\t\t}\n\n\t\t// Top wall\n\t\tif (blob.currentY < this.PHYSICS_MIN + margin * 1.5) {\n\t\t\tblob.currentY = this.PHYSICS_MIN + margin * 1.5;\n\t\t\tblob.velocityY = Math.abs(blob.velocityY) * damping;\n\t\t\tthis.recordBounce(blob, currentTime);\n\t\t}\n\n\t\t// Bottom wall\n\t\tif (blob.currentY > this.PHYSICS_MAX - margin * 1.5) {\n\t\t\tblob.currentY = this.PHYSICS_MAX - margin * 1.5;\n\t\t\tblob.velocityY = -Math.abs(blob.velocityY) * damping;\n\t\t\tthis.recordBounce(blob, currentTime);\n\t\t}\n\t}\n\n\tprivate recordBounce(blob: ConvexBlob, currentTime: number): void {\n\t\tblob.wallBounceCount = (blob.wallBounceCount || 0) + 1;\n\t\tblob.lastBounceTime = currentTime;\n\n\t\t// Add randomness after bounce\n\t\tblob.velocityX += (Math.random() - 0.5) * 0.05;\n\t\tblob.velocityY += (Math.random() - 0.5) * 0.05;\n\n\t\t// Change drift direction\n\t\tblob.driftAngle = Math.random() * Math.PI * 2;\n\n\t\t// Shape disturbance from impact\n\t\tif (blob.controlPoints) {\n\t\t\tblob.chaosLevel = Math.min((blob.chaosLevel || 0) + 0.04, 0.15);\n\t\t}\n\t}\n\n\tprivate generateConvexHull(points: Array<{ x: number; y: number }>): Array<{ x: number; y: number }> {\n\t\tif (points.length < 3) return points;\n\n\t\t// Safety: limit iterations to prevent infinite loops\n\t\tconst maxIterations = points.length * 2;\n\t\tlet iterations = 0;\n\n\t\tconst hull: Array<{ x: number; y: number }> = [];\n\n\t\t// Find bottommost point\n\t\tlet startPoint = points[0];\n\t\tlet startIndex = 0;\n\t\tfor (let i = 0; i < points.length; i++) {\n\t\t\tconst point = points[i];\n\t\t\tif (point.y < startPoint.y || (point.y === startPoint.y && point.x < startPoint.x)) {\n\t\t\t\tstartPoint = point;\n\t\t\t\tstartIndex = i;\n\t\t\t}\n\t\t}\n\n\t\tlet currentIndex = startIndex;\n\t\tdo {\n\t\t\thull.push(points[currentIndex]);\n\t\t\tlet nextIndex = 0;\n\n\t\t\tfor (let i = 0; i < points.length; i++) {\n\t\t\t\tif (nextIndex === currentIndex || this.isLeftTurn(points[currentIndex], points[nextIndex], points[i])) {\n\t\t\t\t\tnextIndex = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcurrentIndex = nextIndex;\n\t\t\titerations++;\n\t\t} while (currentIndex !== startIndex && hull.length < points.length && iterations < maxIterations);\n\n\t\treturn hull;\n\t}\n\n\tprivate isLeftTurn(\n\t\tp1: { x: number; y: number },\n\t\tp2: { x: number; y: number },\n\t\tp3: { x: number; y: number }\n\t): boolean {\n\t\treturn (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x) > 0;\n\t}\n}\n"],"mappings":"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"}